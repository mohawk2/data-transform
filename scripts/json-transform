#!/usr/bin/env perl

use strict;
use warnings;

my $NS = 'http://www.w3.org/2005/xpath-functions';

use JSON::MaybeXS qw(JSON is_bool);
my $j = JSON::MaybeXS->new->allow_nonref->canonical;

if (1) {
my $json = join '', <>;
my $data = $j->decode($json);

#use Data::Dumper;
#print Dumper $data;

my $doc = data2xml($data);
print $doc->toString(1); # pretty
} else {
my $xml = join '', <>;
my $parser = XML::LibXML->new({encoding => "UTF-8"});
my $doc = $parser->load_xml(string => $xml);

my $data = xml2data($doc);

#use Data::Dumper;
#print Dumper $data;

my $new_json = $j->encode($data);
print $new_json;
}

use XML::LibXML;
sub data2xml {
  my ($data) = @_;
  my $doc = XML::LibXML->createDocument("1.0", "UTF-8");
  $doc->addChild(item2elt($data));
  $doc;
}

sub item2elt {
  my ($item) = @_;
  if (ref $item eq 'ARRAY') {
    my $elt = XML::LibXML::Element->new('array');
    $elt->setNamespace($NS, 'j');
    $elt->addChild(item2elt($_)) for @$item;
    return $elt;
  } elsif (ref $item eq 'HASH') {
    my $elt = XML::LibXML::Element->new('map');
    $elt->setNamespace($NS, 'j');
    for my $key (sort keys %$item) {
      my $child = item2elt($item->{$key});
      $elt->addChild($child);
      $child->setAttribute('key', $key);
    }
    return $elt;
  } elsif (is_bool $item) {
    my $elt = XML::LibXML::Element->new('boolean');
    $elt->setNamespace($NS, 'j');
    $elt->setAttribute('value', $item+0 ? 'true' : 'false');
    return $elt;
  } elsif (ref $item) {
    die "Unknown ref type ".ref $item;
  } else {
    if (!defined $item) {
      my $elt = XML::LibXML::Element->new('null');
      $elt->setNamespace($NS, 'j');
      return $elt;
    }
    # if only there were a better way!
    if ($j->encode($item) =~ /^"/) {
      my $elt = XML::LibXML::Element->new('string');
      $elt->setNamespace($NS, 'j');
      $elt->appendTextNode($item);
      return $elt;
    }
    my $elt = XML::LibXML::Element->new('number');
    $elt->setNamespace($NS, 'j');
    $elt->setAttribute('value', $item);
    return $elt;
  }
}

sub xml2data {
  my ($doc) = @_;
  my @nodes = $doc->childNodes;
  die "Should have only one node!" if @nodes != 1;
  elt2item($nodes[0]);
}

sub elt2item {
  my ($elt) = @_;
  my $name = $elt->nodeName;
  if ($name eq 'array') {
    return [ map elt2item($_), grep $_->nodeName ne '#text', $elt->childNodes ];
  } elsif ($name eq 'object') {
    my %hash;
    for my $member ($elt->childNodes) {
      my $member_name = $member->nodeName;
      next if $member_name eq '#text'; # whitespace
      die "Expected 'member', got $member_name" if $member_name ne 'member';
      my $name = $member->getAttribute('name');
      my @children = grep $_->nodeName ne '#text', $member->childNodes;
      die "Expected only 1 child, got ".@children if @children != 1;
      $hash{$name} = elt2item($children[0]);
    }
    return \%hash;
  } elsif ($name eq 'bool') {
    my $value = $elt->getAttribute('value');
    return JSON->$value;
  } elsif ($name eq 'null') {
    return undef;
  } elsif ($name eq 'str') {
    return $elt->firstChild->data;
  } elsif ($name eq 'num') {
    return $elt->getAttribute('value') + 0;
  } else {
    die "Unknown node type $name";
  }
}
